<?xml version="1.0" encoding="UTF-8"?>
<!--
CAUTION: Do not modify this file unless you know what you are doing.
         Unexpected results may occur if the code is changed deliberately.
-->
<dbmodel pgmodeler-ver="0.8.2-beta" last-position="0,0" last-zoom="1"
	 default-schema="public" default-owner="postgres">
<role name="hdus"
      superuser="true"
      encrypted="true"
      validity="2014-05-20 00:00:00"
      password="********">
</role>

<role name="hdus_cp"
      inherit="true"
      encrypted="true"
      password="********">
</role>

<database name="glarus" encoding="UTF8" lc-collate="de_CH" lc-ctype="de_CH">
	<role name="hdus"/>
	<tablespace name="pg_default"/>
</database>

<schema name="public" protected="true" rect-visible="true" fill-color="#e1e1e1" sql-disabled="true">
</schema>

<schema name="versions" rect-visible="true" fill-color="#f5aafc">
	<role name="hdus_cp"/>
</schema>

<usertype name="checkout" configuration="composite">
	<schema name="versions"/>
	<role name="hdus"/>
	<typeattrib name="mykey">
		<type name="integer"/>
	</typeattrib>
	<typeattrib name="action">
		<type name="character varying"/>
	</typeattrib>
	<typeattrib name="revision">
		<type name="integer"/>
	</typeattrib>
	<typeattrib name="systime">
		<type name="bigint"/>
	</typeattrib>
</usertype>

<usertype name="conflicts" configuration="composite">
	<schema name="versions"/>
	<role name="hdus"/>
	<typeattrib name="objectkey">
		<type name="integer"/>
	</typeattrib>
	<typeattrib name="myproject">
		<type name="text"/>
	</typeattrib>
	<typeattrib name="mysystime">
		<type name="bigint"/>
	</typeattrib>
	<typeattrib name="project">
		<type name="text"/>
	</typeattrib>
	<typeattrib name="systime">
		<type name="bigint"/>
	</typeattrib>
</usertype>

<usertype name="logview" configuration="composite">
	<schema name="versions"/>
	<role name="hdus"/>
	<typeattrib name="revision">
		<type name="integer"/>
	</typeattrib>
	<typeattrib name="datum">
		<type name="timestamp"/>
	</typeattrib>
	<typeattrib name="project">
		<type name="text"/>
	</typeattrib>
	<typeattrib name="logmsg">
		<type name="text"/>
	</typeattrib>
</usertype>

<function name="pgvscheck"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="1000">
	<schema name="versions"/>
	<role name="hdus"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="versions.conflicts" precision="32616"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[

  DECLARE
    inTable ALIAS FOR $1;
    mySchema TEXT;
    myTable TEXT;
    myPkey TEXT;
    message TEXT;
    myDebug TEXT;
    myPkeyRec record;
    conflict BOOLEAN;
    conflictCheck versions.conflicts%rowtype;
    pos integer;
    versionLogTable TEXT;

  BEGIN	
    pos := strpos(inTable,'.');
    conflict := False;
  
    if pos=0 then 
        mySchema := 'public';
  	myTable := inTable; 
    else 
        mySchema := substr(inTable,0,pos);
        pos := pos + 1; 
        myTable := substr(inTable,pos);
    END IF;  
    
    versionLogTable := 'versions."'||mySchema||'_'||myTable||'_version_log"';   

  -- Pruefen ob und welche Spalte der Primarykey der Tabelle ist 
    select into myPkeyRec col.column_name 
    from information_schema.table_constraints as key,
         information_schema.key_column_usage as col
    where key.table_schema = mySchema::name
      and key.table_name = myTable::name
      and key.constraint_type='PRIMARY KEY'
      and key.constraint_name = col.constraint_name
      and key.table_catalog = col.table_catalog
      and key.table_schema = col.table_schema
      and key.table_name = col.table_name;	
  
    IF FOUND THEN
       myPkey := myPkeyRec.column_name;
    else
        RAISE EXCEPTION 'Table % does not have Primarykey defined', mySchema||'.'||myTable;
    END IF;    
    
/*
Check for conflicts before committing. When conflicts are existing stop the commit process 
with a listing of the conflicting objects.
*/    

    message := '';
            
  myDebug := ' select a.'||myPkey||', myproject, mysystime, project, systime 
                         from ( 
                              select '||myPkey||', project as myproject, max(systime) as mysystime
                              from '||versionLogTable||'
                              where not commit 
                                and project = current_user
                              group by '||myPkey||', project
                             ) as a,
                             (
                              select '||myPkey||', project, max(systime) as systime 
                              from '||versionLogTable||'
                              where commit and project <> current_user
                              group by '||myPkey||', project
                             ) as b
                         where b.systime > a.mysystime
                             and a.'||myPkey||' = b.'||myPkey;

--RAISE EXCEPTION '%',myDebug;                                    
                                    
    for conflictCheck IN  EXECUTE myDebug
    LOOP

      return next conflictCheck;
      conflict := True;
      message := message||E'\n'||'WARNING! The object with '||myPkey||'='||conflictCheck.objectkey||' is also changed by user '||conflictCheck.project||'.';
    END LOOP;    
              
    message := message||E'\n\n';
    message := message||'Changes are not committed!'||E'\n\n';
    IF conflict THEN
       RAISE NOTICE '%', message;
    ELSE    
       return;    
  END IF;    

  END;


]]></definition>
</function>

<function name="pgvscommit"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="1000">
	<schema name="versions"/>
	<role name="hdus"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="versions.conflicts" precision="0"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying"/>
	</parameter>
	<parameter name="_param2">
		<type name="text"/>
	</parameter>
	<definition><![CDATA[

  DECLARE
    inTable ALIAS FOR $1;
    logMessage ALIAS FOR $2;
    mySchema TEXT;
    myTable TEXT;
    myPkey TEXT;
    fields TEXT;
    insFields TEXT;
    message TEXT;
    myDebug TEXT;
    commitQuery TEXT;
    checkQuery TEXT;
    myPkeyRec record;
    attributes record;
    testRec record;
    conflict BOOLEAN;
    conflictCheck versions.conflicts%rowtype;
    pos integer;
    versionLogTable TEXT;
    revision integer;

  BEGIN	
    pos := strpos(inTable,'.');
    fields := '';
    insFields := '';
    conflict := False;
  
    if pos=0 then 
        mySchema := 'public';
  	    myTable := inTable; 
    else 
        mySchema := substr(inTable,0,pos);
        pos := pos + 1; 
        myTable := substr(inTable,pos);
    END IF;  
    
    versionLogTable := 'versions."'||mySchema||'_'||myTable||'_version_log"';   

  -- Pruefen ob und welche Spalte der Primarykey der Tabelle ist 
    select into myPkeyRec col.column_name 
    from information_schema.table_constraints as key,
         information_schema.key_column_usage as col
    where key.table_schema = mySchema::name
      and key.table_name = myTable::name
      and key.constraint_type='PRIMARY KEY'
      and key.constraint_name = col.constraint_name
      and key.table_catalog = col.table_catalog
      and key.table_schema = col.table_schema
      and key.table_name = col.table_name;	
  
    IF FOUND THEN
       myPkey := myPkeyRec.column_name;
    else
        RAISE EXCEPTION 'Table % does not have Primarykey defined', mySchema||'.'||myTable;
    END IF;    
    
/*
Check for conflicts before committing. When conflicts are existing stop the commit process 
with a listing of the conflicting objects.
*/    
  message := '';
            
  myDebug := ' select a.'||myPkey||', myproject, mysystime, project, systime 
                         from ( 
                              select '||myPkey||', project as myproject, max(systime) as mysystime
                              from '||versionLogTable||'
                              where not commit 
                                and project = current_user
                              group by '||myPkey||', project
                             ) as a,
                             (
                              select '||myPkey||', project, systime 
                              from '||versionLogTable||'
                              where commit and project <> current_user
                             ) as b
                         where b.systime > a.mysystime
                             and a.'||myPkey||' = b.'||myPkey;

--RAISE EXCEPTION '%',myDebug;                                    
                                    
    for conflictCheck IN  EXECUTE myDebug
    LOOP

      return next conflictCheck;
      conflict := True;
      message := message||E'\n'||'WARNING! The object with '||myPkey||'='||conflictCheck.objectkey||' is also changed by user '||conflictCheck.project||'.';
    END LOOP;    
              
    message := message||E'\n\n';
    message := message||'Changes are not committed!'||E'\n\n';
    IF conflict THEN
       RAISE NOTICE '%', message;
    ELSE    
    
         execute 'create temp table tmp_tab as 
       select project
       from '||versionLogTable||'
       where not commit ';

         select into testRec project from tmp_tab;

        IF NOT FOUND THEN
          execute 'drop table tmp_tab';
          RETURN;
        ELSE  
          execute 'drop table tmp_tab';
          for attributes in select *
                            from  information_schema.columns
                            where table_schema=mySchema::name
                              and table_name = myTable::name

              LOOP
                
                if attributes.column_name <> 'OID' 
                  and attributes.column_name <> 'versionarchive' 
                  and attributes.column_name <> 'new_date' 
                  and  attributes.column_name <> 'archive_date' 
                  and  attributes.column_name <> 'archive' then
                    fields := fields||',log."'||attributes.column_name||'"';
                    insFields := insFields||',"'||attributes.column_name||'"';
                END IF;
              END LOOP;    
            
              fields := substring(fields,2);
              insFields := substring(insFields,2);     
            
          revision := nextval('versions."'||mySchema||'_'||myTable||'_version_log_seq"');
         
          commitQuery := 'delete from '||versionLogTable||'
                using (
                    select log.* from '||versionLogTable||' as log,
                       ( 
                    select '||myPkey||', max(systime) as systime, max(revision) as revision
                    from '||versionLogTable||'
                    where not commit and project = current_user
                    group by '||myPkey||') as foo
                    where log.project = current_user
                      and foo.'||myPkey||' = log.'||myPkey||'
                      and foo.systime <> log.systime
                      and not commit) as foo
                where '||versionLogTable||'.'||myPkey||' = foo.'||myPkey||'
                  and '||versionLogTable||'.systime = foo.systime
                  and '||versionLogTable||'.project = foo.project
                  and '||versionLogTable||'.revision = foo.revision;
                  
              delete from "'||mySchema||'"."'||myTable||'" where '||myPkey||' in 
                   (select '||myPkey||'
                    from  '||versionLogTable||'
                             where not commit
                               and project = current_user
                             group by '||myPkey||', project);
   
              insert into "'||mySchema||'"."'||myTable||'" ('||insFields||') 
                    select '||fields||' from '||versionLogTable||' as log,
                       (
                        select '||myPKey||', max(systime) as systime, max(revision) as revision
                        from '||versionLogTable||'
                        where project = current_user
                          and not commit
                          and action <> ''delete''
                        group by '||myPKey||'
                       ) as foo
                    where log.'||myPkey||'= foo.'||myPkey||'
                      and log.systime = foo.systime
                      and log.action <> ''delete'';
                      
                update '||versionLogTable||' set 
                         commit = True, 
                         revision = '||revision||', 
                         logmsg = '''||logMessage ||''',    
                         systime = ' || EXTRACT(EPOCH FROM now()::TIMESTAMP)*1000 || '
                    where not commit
                      and project = current_user;';

--RAISE EXCEPTION '%',commitQuery;

     execute 'INSERT INTO versions.version_tables_logmsg(
                version_table_id, revision, logmsg) 
              SELECT version_table_id, '||revision||', '''||logMessage||''' as logmsg FROM versions.version_tables where version_table_schema = '''||mySchema||''' and version_table_name = '''|| myTable||''''; 
                      

        execute commitQuery;              
     END IF;
  END IF;    

  RETURN;                             

  END;


]]></definition>
</function>

<function name="pgvsdiff"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="1000">
	<schema name="versions"/>
	<role name="hdus"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="record"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying"/>
	</parameter>
	<parameter name="_param2">
		<type name="integer"/>
	</parameter>
	<parameter name="_param3">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
  DECLARE
    inTable ALIAS FOR $1;
    majorRevision ALIAS FOR $2;
    minorRevision ALIAS FOR $3;
    mySchema TEXT;
    myTable TEXT;
    myPkey TEXT;
    message TEXT;
    diffQry TEXT;
    myPkeyRec record;
    conflict BOOLEAN;
    pos integer;
    versionLogTable TEXT;
    diffRec record;

  BEGIN	
    pos := strpos(inTable,'.');
    conflict := False;
  
    if pos=0 then 
        mySchema := 'public';
  	    myTable := inTable; 
    else 
        mySchema := substr(inTable,0,pos);
        pos := pos + 1; 
        myTable := substr(inTable,pos);
    END IF;  
    
    versionLogTable := 'versions.'||mySchema||'_'||myTable||'_version_log';   

  -- Pruefen ob und welche Spalte der Primarykey der Tabelle ist 
    select into myPkeyRec col.column_name 
    from information_schema.table_constraints as key,
         information_schema.key_column_usage as col
    where key.table_schema = mySchema::name
      and key.table_name = myTable::name
      and key.constraint_type='PRIMARY KEY'
      and key.constraint_name = col.constraint_name
      and key.table_catalog = col.table_catalog
      and key.table_schema = col.table_schema
      and key.table_name = col.table_name;	
  
    IF FOUND THEN
       myPkey := myPkeyRec.column_name;
    else
        RAISE EXCEPTION 'Table % does not have Primarykey defined', mySchema||'.'||myTable;
    END IF;    

     diffQry := ' select '||myPkey||',
                         case 
                           when count(action) = 2 then ''update''
                           else max(action)
                         end as action,
                         revision, systime, logmsg
            from (
            select '||myPkey||', action, revision, systime, logmsg 
            from '||versionLogTable||' 
            where revision = '||majorRevision||'
            union
            select '||myPkey||', action, revision, systime, logmsg 
            from '||versionLogTable||'  
            where revision = '||minorRevision||'
              and '||myPkey||' in (select '||myPkey||' from '||versionLogTable||' where revision = '||majorRevision||')
            order by '||myPkey||', revision desc, action desc) as foo
            group by '||myPkey||', systime, revision, logmsg
            order by revision desc, '||myPkey;


/*
            
select a.gid,
             case 
               when count(a.action) = 2 then 'update'
               else max(a.action)
             end as action, a.revision, a.systime
  
from versions.public_test_poly_version_log as a, (
  SELECT public_test_poly_version_log.gid, public_test_poly_version_log.name
  FROM versions.public_test_poly_version_log
  WHERE public_test_poly_version_log.revision=1
  Intersect
  SELECT public_test_poly_version_log.gid, public_test_poly_version_log.name
  FROM versions.public_test_poly_version_log
  WHERE public_test_poly_version_log.revision=3) as foo
where (a.gid = foo.gid and a.revision=1)    
   or (a.gid = foo.gid and a.revision=3)
group by a.gid, a.systime, a.revision, a.logmsg   
order by revision desc, a.gid            
  */          
            
            
RAISE EXCEPTION '%', diffQry;            
            
    for diffRec IN  EXECUTE diffQry
    LOOP
      return next diffRec;
    END LOOP;    

 
  END;


]]></definition>
</function>

<function name="pgvsdrop"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="versions"/>
	<role name="hdus"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
  DECLARE
    inTable ALIAS FOR $1;
    pos INTEGER;
    mySchema TEXT;
    myTable TEXT;
    versionTableRec record;
    versionTable TEXT;
    versionView TEXT;
    versionLogTable TEXT;
    versionLogTableSeq TEXT;
    geomCol TEXT;
    geomType TEXT;
    geomDIM INTEGER;
    geomSRID INTEGER;
    testRec record;
    testTab TEXT;
    

  BEGIN	
    pos := strpos(inTable,'.');
    geomCol := '';
    geomDIM := 2;
    geomSRID := -1;
    geomType := '';

    if pos=0 then 
        mySchema := 'public';
  	    myTable := inTable; 
    else 
        mySchema = substr(inTable,0,pos);
        pos := pos + 1; 
        myTable = substr(inTable,pos);
    END IF;  

    versionView := '"'||mySchema||'"."'||myTable||'_version"';
    versionLogTable := 'versions."'||mySchema||'_'||myTable||'_version_log"';
    versionLogTableSeq := 'versions."'||mySchema||'_'||myTable||'_version_log_seq"';

-- Feststellen ob die Tabelle existiert
     select into testRec table_name
     from information_schema.tables
     where table_schema = mySchema::name
          and table_name = myTable::name;

     IF NOT FOUND THEN
       RAISE EXCEPTION 'Table %.% does not exist', mySchema,myTable;
       RETURN False;
     END IF;    
     
-- Feststellen ob die Log-Tabelle existiert
     testTab := mySchema||'_'||myTable||'_version_log';
     
     select into testRec table_name
     from information_schema.tables
     where table_schema = 'versions'
          and table_name = testTab::name;

     IF NOT FOUND THEN
       RAISE EXCEPTION 'Log Table %.% does not exist', mySchema,myTable;
       RETURN False;
     END IF;        
 
     
-- Die grundlegenden Geometrieparameter des Ausgangslayers ermitteln
     select into testRec f_geometry_column, coord_dimension, srid, type
     from geometry_columns
     where f_table_schema = mySchema::name
       and f_table_name = myTable::name;

     geomCol := testRec.f_geometry_column;
     geomDIM := testRec.coord_dimension;
     geomSRID := testRec.srid;
     geomType := testRec.type;
     
     execute 'create temp table tmp_tab as 
       select project
       from '||versionLogTable||'
       where not commit ';

     select into testRec project
     from tmp_tab;

     IF FOUND THEN
       RAISE EXCEPTION 'Uncommitted Records are existing. Please commit all changes before use pgvsdrop()';
       RETURN False;
     END IF;  

     select into versionTableRec version_table_id as vtid
     from versions.version_tables as vt
     where version_table_schema = mySchema::name
       and version_table_name = myTable::name;

     

    execute 'DROP SEQUENCE if exists '||versionLogTableSeq;
    execute 'drop table if exists '||versionLogTable||' cascade;';

    
    execute 'delete from versions.version_tables 
               where version_table_id = '''||versionTableRec.vtid||''';';

    execute 'delete from versions.version_tables_logmsg 
               where version_table_id = '''||versionTableRec.vtid||''';';

/*
    execute 'delete from public.geometry_columns 
              where f_table_schema = ''versions''
                and f_table_name = '''||myTable||'_version_log''
                and f_geometry_column = '''||geomCol||'''
                and coord_dimension = '||geomDIM||'
                and srid = '||geomSRID||'
                and type = '''||geomTYPE||''';';
                
    execute 'delete from public.geometry_columns 
               where f_table_schema = '''||mySchema||'''
                 and f_table_name = '''||myTable||'_version''
                 and f_geometry_column = '''||geomCol||'''
                 and coord_dimension = '||geomDIM||'
                 and srid = '||geomSRID||'
                 and type = '''||geomTYPE||''';';
*/
  RETURN true ;                             

  END;
]]></definition>
</function>

<function name="pgvsinit"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="versions"/>
	<role name="hdus"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
  DECLARE
    inTable ALIAS FOR $1;
    pos INTEGER;
    mySchema TEXT;
    myTable TEXT;
    versionTable TEXT;
    versionView TEXT;
    versionLogTable TEXT;
    versionLogTableSeq TEXT;
    versionLogTableTmp TEXT;
    geomCol TEXT;
    geomType TEXT;
    geomDIM INTEGER;
    geomSRID INTEGER;
    attributes record;
    testRec record;
    testPKey record;
    fields TEXT;
    newFields TEXT;
    oldFields TEXT;
    updateFields TEXT;
    mySequence TEXT;
    myPkey TEXT;
    myPkeyRec record;
    testTab TEXT;
    archiveWhere TEXT;
    

  BEGIN	
    pos := strpos(inTable,'.');
    fields := '';
    newFields := '';
    oldFields := '';
    updateFields := '';
    geomCol := '';
    geomDIM := 2;
    geomSRID := -1;
    geomType := '';
    mySequence := '';
    archiveWhere := '';

    if pos=0 then 
        mySchema := 'public';
  	myTable := inTable; 
    else 
        mySchema = substr(inTable,0,pos);
        pos := pos + 1; 
        myTable = substr(inTable,pos);
    END IF;  

    versionTable := '"'||mySchema||'"."'||myTable||'_version_t"';
    versionView := '"'||mySchema||'"."'||myTable||'_version"';
    versionLogTable := 'versions."'||mySchema||'_'||myTable||'_version_log"';
    versionLogTableSeq := 'versions."'||mySchema||'_'||myTable||'_version_log_seq"';
    versionLogTableTmp := 'versions."'||mySchema||'_'||myTable||'_version_log_tmp"';

-- Feststellen ob die Tabelle oder der View existiert
     select into testRec table_name
     from information_schema.tables
     where table_schema = mySchema::name
          and table_name = myTable::name;

     IF NOT FOUND THEN
       select into testRec table_name
       from information_schema.views
       where table_schema = mySchema::name
            and table_name = myTable::name;     
       IF NOT FOUND THEN
         RAISE EXCEPTION 'Table %.% does not exist', mySchema,myTable;
         RETURN False;
       END IF;
     END IF;    
 
 
-- Die grundlegenden Geometrieparameter des Ausgangslayers ermitteln
     select into testRec f_geometry_column, coord_dimension, srid, type
     from geometry_columns
     where f_table_schema = mySchema::name
       and f_table_name = myTable::name;

     IF NOT FOUND THEN
       RAISE EXCEPTION 'Table %.% is not registered in geometry_columns', mySchema, myTable;
       RETURN False;
     END IF;

     geomCol := testRec.f_geometry_column;
     geomDIM := testRec.coord_dimension;
     geomSRID := testRec.srid;
     geomType := testRec.type;

     
-- Pruefen ob und welche Spalte der Primarykey der Tabelle old_layer ist 
    select into testPKey col.column_name 
    from information_schema.table_constraints as key,
         information_schema.key_column_usage as col
    where key.table_schema = mySchema::name
      and key.table_name = myTable::name
      and key.constraint_type='PRIMARY KEY'
      and key.constraint_name = col.constraint_name
      and key.table_catalog = col.table_catalog
      and key.table_schema = col.table_schema
      and key.table_name = col.table_name;	
  
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Table %.% has no Primarykey', mySchema, myTable;
        RETURN False;
    END IF;			
       
-- Feststellen ob die Tabelle bereits besteht
     testTab := '"versions"."'||myTable||'_version_log"';
     select into testRec table_name
     from information_schema.tables
     where table_schema = mySchema::name
          and table_name = testTab::name;

     IF FOUND THEN
       RAISE NOTICE 'Table %.% has been deleted', mySchema,testTab;
       execute 'drop table "'||mySchema||'"."'||testTab||'" cascade';
     END IF;    
  
-- Feststellen ob die Log-Tabelle bereits in geometry_columns registriert ist
     select into testRec f_table_name
     from geometry_columns
     where f_table_schema = mySchema::name
          and f_table_name = testTab::name;
          
     IF FOUND THEN
       execute 'delete from geometry_columns where f_table_schema='''||mySchema||''' and f_table_name='''||myTable||'_version_log''';
     END IF;    

-- Feststellen ob der View bereits in geometry_columns registriert ist
     testTab := '"'||mySchema||'"."'||myTable||'_version"';
     select into testRec f_table_name
     from geometry_columns
     where f_table_schema = mySchema::name
          and f_table_name = testTab::name;

     IF FOUND THEN
       execute 'delete from geometry_columns where f_table_schema='''||mySchema||''' and f_table_name='''||myTable||'_version''';
     END IF;    
     
     
  -- Pruefen ob und welche Spalte der Primarykey der Tabelle ist 
    select into myPkeyRec col.column_name 
    from information_schema.table_constraints as key,
         information_schema.key_column_usage as col
    where key.table_schema = mySchema::name
      and key.table_name = myTable::name
      and key.constraint_type='PRIMARY KEY'
      and key.constraint_name = col.constraint_name
      and key.table_catalog = col.table_catalog
      and key.table_schema = col.table_schema
      and key.table_name = col.table_name;	
  
    IF FOUND THEN
       myPkey := '"'||myPkeyRec.column_name||'"';
    else
        RAISE EXCEPTION 'Table % has no Primarykey', mySchema||'.'||myTable;
        RETURN False;
    END IF;

    execute 'create table '||versionLogTable||' (LIKE "'||mySchema||'"."'||myTable||'");
             CREATE SEQUENCE '||versionLogTableSeq||' INCREMENT 1 START 1;
             GRANT ALL ON TABLE '||versionLogTable||' TO public;
             GRANT ALL ON TABLE '||versionLogTableSeq||' TO public;
             alter table '||versionLogTable||' add column version_log_id bigserial;
             alter table '||versionLogTable||' add column action character varying;
             alter table '||versionLogTable||' add column project character varying default current_user;     
             alter table '||versionLogTable||' add column systime bigint default extract(epoch from now()::timestamp)*1000;    
             alter table '||versionLogTable||' add column revision bigint;
             alter table '||versionLogTable||' add column logmsg text;        
             alter table '||versionLogTable||' add column commit boolean DEFAULT False;
             create index '||myTable||'_version_geo_idx on '||versionLogTable||' USING GIST ('||geomCol||');     
             insert into versions.version_tables (version_table_schema,version_table_name,version_view_schema,version_view_name,version_view_pkey,version_view_geometry_column) 
                 values('''||mySchema||''','''||myTable||''','''||mySchema||''','''||myTable||'_version'','''||testPKey.column_name||''','''||geomCol||''');
             insert into public.geometry_columns (f_table_catalog, f_table_schema,f_table_name,f_geometry_column,coord_dimension,srid,type)
                 values ('''',''versions'','''||myTable||'_version_log'','''||geomCol||''','||geomDIM||','||geomSRID||','''||geomTYPE||''');
             insert into public.geometry_columns (f_table_catalog, f_table_schema,f_table_name,f_geometry_column,coord_dimension,srid,type)
               values ('''','''||mySchema||''','''||myTable||'_version'','''||geomCol||''','||geomDIM||','||geomSRID||','''||geomTYPE||''');';
    
    for attributes in select *
                      from  information_schema.columns
                      where table_schema=mySchema::name
                        and table_name = myTable::name

        LOOP
          
          if attributes.column_default LIKE 'nextval%' then
             execute 'alter table '||versionLogTable||' alter column '||attributes.column_name||' drop not null';
             mySequence := attributes.column_default;
          ELSE
            if myPkey <> attributes.column_name then
              fields := fields||',"'||attributes.column_name||'"';
              newFields := newFields||',new."'||attributes.column_name||'"';
              oldFields := oldFields||',old."'||attributes.column_name||'"';
              updateFields := updateFields||',"'||attributes.column_name||'"=new."'||attributes.column_name||'"';
            END IF;
          END IF;
          IF attributes.column_name = 'archive' THEN
            archiveWhere := 'and archive=0';           
          END IF;  
        END LOOP;

-- Das erste Komma  aus dem String entfernen
        fields := substring(fields,2);
        newFields := substring(newFields,2);
        oldFields := substring(oldFields,2);
        updateFields := substring(updateFields,2);
        
        IF length(mySequence)=0 THEN
          RAISE EXCEPTION 'No Sequence defined for Table %.%', mySchema,myTable;
          RETURN False;
        END IF;

     execute 'alter table '||versionLogTable||' add constraint '||myTable||'_pkey primary key ('||myPkey||',project,systime,action) ';  
     execute 'CREATE INDEX '||mySchema||'_'||myTable||'_version_log_id_idx ON '||versionLogTable||' USING btree (version_log_id)';
     
     execute 'create or replace view '||versionView||' as 
             select * from (
               select v.'||myPkey||','||fields||' 
               from '||versionLogTable||' as v,
               (
                  select '||myPkey||', max(systime) as systime
                  from 
                    (
                      select '||myPkey||', systime   
                      from '||versionLogTable||'
                      where commit
                      union
                      select '||myPkey||', max(systime) as systime
                      from   
                        (
                          SELECT '||myPkey||', systime
                          FROM '||versionLogTable||'
                          WHERE project = CURRENT_USER
                        ) as foo
                        group by '||myPkey||'
                    ) as foo
                    group by '||myPkey||'
                ) as foo
                where v.'||myPkey||' = foo.'||myPkey||' and v.systime = foo.systime and v.action <> ''delete'') as foo;
             GRANT ALL ON TABLE '||versionView||' TO public;';    
            
             
    execute 'CREATE OR REPLACE RULE delete AS
                ON DELETE TO '||versionView||' DO INSTEAD  
                INSERT INTO '||versionLogTable||' ('||myPkey||','||fields||',action) VALUES (old.'||myPkey||','||oldFields||',''delete'')';                

       
    execute 'CREATE OR REPLACE RULE insert AS
                ON INSERT TO '||versionView||' DO INSTEAD  
                INSERT INTO '||versionLogTable||' ('||myPkey||','||fields||',action) VALUES ('||mySequence||','||newFields||',''insert'')';
          
     execute 'CREATE OR REPLACE RULE update AS
                ON UPDATE TO '||versionView||' DO INSTEAD  
                INSERT INTO '||versionLogTable||' ('||myPkey||','||fields||',action) VALUES (old.'||myPkey||','||newFields||',''update'')'; 

     execute 'INSERT INTO '||versionLogTable||' ('||myPkey||','||fields||', action, revision, logmsg, commit ) 
                select '||myPkey||','||fields||', ''insert'' as action, 0 as revision, ''initial commit revision 0'' as logmsg, ''t'' as commit 
                from "'||mySchema||'"."'||myTable||'"';                          

     execute 'INSERT INTO versions.version_tables_logmsg(
                version_table_id, revision, logmsg) 
              SELECT version_table_id, 0 as revision, ''initial commit revision 0'' as logmsg FROM versions.version_tables where version_table_schema = '''||mySchema||''' and version_table_name = '''|| myTable||''''; 
                
  RETURN true ;                             

  END;
]]></definition>
</function>

<function name="pgvslogview"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="1000">
	<schema name="versions"/>
	<role name="hdus"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="versions.logview" precision="0"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[    
  DECLARE
    inTable ALIAS FOR $1;
    mySchema TEXT;
    myTable TEXT;
    logViewQry TEXT;
    versionLogTable TEXT;
    pos integer;
    logs versions.logview%rowtype;


  BEGIN	
    pos := strpos(inTable,'.');
  
    if pos=0 then 
        mySchema := 'public';
  	    myTable := inTable; 
    else 
        mySchema := substr(inTable,0,pos);
        pos := pos + 1; 
        myTable := substr(inTable,pos);
    END IF;  
    
    versionLogTable := 'versions."'||mySchema||'_'||myTable||'_version_log"';       

    logViewQry := 'select logt.revision, to_timestamp(logt.systime/1000), logt.project,  logt.logmsg
                           from  versions.version_tables as vt, versions.version_tables_logmsg as logt
                           where vt.version_table_id = logt.version_table_id
                             and vt.version_table_schema = '''||mySchema||'''
                             and vt.version_table_name = '''||myTable||''' 
                           order by revision desc';

--RAISE EXCEPTION '%', logViewQry;

                           
    for logs IN  EXECUTE logViewQry
    LOOP

      return next logs;    
    end loop;                       
  
  END;
]]></definition>
</function>

<function name="pgvsmerge"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="versions"/>
	<role name="hdus"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="inTable">
		<type name="character varying"/>
	</parameter>
	<parameter name="targetGid">
		<type name="integer"/>
	</parameter>
	<parameter name="targetProject">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[  DECLARE
    inTable ALIAS FOR $1;
    targetGid ALIAS FOR $2;
    targetProject ALIAS FOR $3;
    mySchema TEXT;
    myTable TEXT;
    myPkey TEXT;
    myDebug TEXT;
    myPkeyRec record;
    conflict BOOLEAN;
    conflictCheck record;
    pos integer;
    versionLogTable TEXT;

  BEGIN	
    pos := strpos(inTable,'.');
    conflict := False;
  
    if pos=0 then 
        mySchema := 'public';
  	    myTable := inTable; 
    else 
        mySchema := substr(inTable,0,pos);
        pos := pos + 1; 
        myTable := substr(inTable,pos);
    END IF;  
    
    versionLogTable := 'versions."'||mySchema||'_'||myTable||'_version_log"';   

  -- Pruefen ob und welche Spalte der Primarykey der Tabelle ist 
    select into myPkeyRec col.column_name 
    from information_schema.table_constraints as key,
         information_schema.key_column_usage as col
    where key.table_schema = mySchema::name
      and key.table_name = myTable::name
      and key.constraint_type='PRIMARY KEY'
      and key.constraint_name = col.constraint_name
      and key.table_catalog = col.table_catalog
      and key.table_schema = col.table_schema
      and key.table_name = col.table_name;	
  
    IF FOUND THEN
       myPkey := myPkeyRec.column_name;
    else
        RAISE EXCEPTION 'Table % does not have Primarykey defined', mySchema||'.'||myTable;
        RETURN False;
    END IF;    
        

        
myDebug := 'select a.'||myPkey||' as objectkey, b.systime, b.project as myuser
                                  from '||versionLogTable||' as a,
                                       (
                                         select '||myPkey||', systime, project
                                         from '||versionLogTable||'
                                         where commit
                                           and project <> '''||targetProject||''') as b
                                  where not commit
                                    and a.systime < b.systime
                                    and a.'||myPkey||' = b.'||myPkey||'
                                    and a.'||myPkey||' = '||targetGid||'
                                  union
                                  select '||myPkey||',systime, project
                                  from '||versionLogTable||' as a
                                  where not commit 
                                    and project <> '''||targetProject||'''
                                    and '||myPkey||' = '||targetGid||''; 
                                                                 
-- RAISE EXCEPTION '%',myDebug;    
    
    for conflictCheck IN EXECUTE myDebug
    LOOP
       RAISE NOTICE '%  %',conflictCheck.objectkey,conflictCheck.systime;

      myDebug := 'delete from '||versionLogTable||' 
                     where '||myPkey||' = '||conflictCheck.objectkey||' 
                        and project = '''||conflictCheck.myuser||'''
                        and systime = '||conflictCheck.systime||' ';
-- RAISE EXCEPTION '%', myDebug;                        
      execute myDebug;
                      
    END LOOP; 
  
  RETURN True;
  
  END;]]></definition>
</function>

<function name="pgvsrevert"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="versions"/>
	<role name="hdus"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
  DECLARE
    inTable ALIAS FOR $1;
    pos INTEGER;
    mySchema TEXT;
    myTable TEXT;
    versionTable TEXT;
    versionView TEXT;
    versionLogTable TEXT;
    geomCol TEXT;
    geomType TEXT;
    geomDIM INTEGER;
    geomSRID INTEGER;
    revision INTEGER;
    testRec record;
    testTab TEXT;
    

  BEGIN	
    pos := strpos(inTable,'.');
    geomCol := '';
    geomDIM := 2;
    geomSRID := -1;
    geomType := '';

    if pos=0 then 
        mySchema := 'public';
  	    myTable := inTable; 
    else 
        mySchema = substr(inTable,0,pos);
        pos := pos + 1; 
        myTable = substr(inTable,pos);
    END IF;  

    versionView := mySchema||'.'||myTable||'_version';
    versionLogTable := 'versions."'||mySchema||'_'||myTable||'_version_log"';

-- Feststellen ob die Tabelle existiert
     select into testRec table_name
     from information_schema.tables
     where table_schema = mySchema::name
          and table_name = myTable::name;

     IF NOT FOUND THEN
       RAISE EXCEPTION 'Table %.% does not exist', mySchema,myTable;
       RETURN False;
     END IF;    
     
-- Feststellen ob die Log-Tabelle existiert
     testTab := mySchema||'_'||myTable||'_version_log';
     
     select into testRec table_name
     from information_schema.tables
     where table_schema = 'versions'
          and table_name = testTab::name;

     IF NOT FOUND THEN
       RAISE EXCEPTION 'Log Table %.% does not exist', mySchema,myTable;
       RETURN False;
     END IF;        
 
     execute 'select max(revision) from '||versionLogTable into revision;
     
     execute 'delete from '||versionLogTable||' 
                    where project = current_user
                      and not commit';
                    
  RETURN revision ;                             

  END;
]]></definition>
</function>

<function name="pgvsrevision"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="versions"/>
	<role name="hdus"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<definition><![CDATA[    
DECLARE
  revision TEXT;
  BEGIN	
    revision := '1.8.4';
  RETURN revision ;                             

  END;
]]></definition>
</function>

<function name="pgvsrollback"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="versions"/>
	<role name="hdus"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying"/>
	</parameter>
	<parameter name="_param2">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
  DECLARE
    inTable ALIAS FOR $1;
    myRevision ALIAS FOR $2;
    pos INTEGER;
    mySchema TEXT;
    myTable TEXT;
    versionTable TEXT;
    versionView TEXT;
    versionLogTable TEXT;
    attributes record;
    fields TEXT;
    archiveWhere TEXT;
    myPKeyRec Record;
    myPkey Text;
    rollbackQry Text;
    myInsertFields Text;
    

  BEGIN	
    pos := strpos(inTable,'.');
    fields := '';
    myInsertFields := '';
    archiveWhere := '';


    if pos=0 then 
        mySchema := 'public';
  	    myTable := inTable; 
    else 
        mySchema = substr(inTable,0,pos);
        pos := pos + 1; 
        myTable = substr(inTable,pos);
    END IF;  
    
  -- Pruefen ob und welche Spalte der Primarykey der Tabelle ist 
    select into myPkeyRec col.column_name 
    from information_schema.table_constraints as key,
         information_schema.key_column_usage as col
    where key.table_schema = mySchema::name
      and key.table_name = myTable::name
      and key.constraint_type='PRIMARY KEY'
      and key.constraint_name = col.constraint_name
      and key.table_catalog = col.table_catalog
      and key.table_schema = col.table_schema
      and key.table_name = col.table_name;	
  
    myPkey := myPkeyRec.column_name;

    versionTable := '"'||mySchema||'"."'||myTable||'_version_t"';
    versionView := '"'||mySchema||'"."'||myTable||'_version"';
    versionLogTable := 'versions."'||mySchema||'_'||myTable||'_version_log"';
    
    for attributes in select *
                               from  information_schema.columns
                               where table_schema=mySchema::name
                                    and table_name = myTable::name

        LOOP
          
          if attributes.column_name not in ('action','project','systime','revision','logmsg','commit') then
            fields := fields||',v."'||attributes.column_name||'"';
            myInsertFields := myInsertFields||',"'||attributes.column_name||'"';
          END IF;

          END LOOP;

-- Das erste Komma  aus dem String entfernen
        fields := substring(fields,2);
        myInsertFields := substring(myInsertFields,2);


execute 'select versions.pgvsrevert('''||mySchema||'.'||myTable||''')';

rollbackQry := 'insert into '||versionLogTable||' ('||myInsertFields||', action)
                select '||fields||', ''delete'' as action 
                from '||versionLogTable||' as v, 
                  (select v.'||myPkey||', max(v.version_log_id) as version_log_id
                   from '||versionLogTable||' as v,
                (select v.'||myPkey||'
                 from '||versionLogTable||' as v,
                  (select v.'||myPkey||'
                   from '||versionLogTable||' as v
                   where revision > '||myRevision||'
                   except
                   select v.'||myPkey||'
                   from '||versionLogTable||' as v
                   where revision <= '||myRevision||'
                  ) as foo
                 where v.'||myPkey||' = foo.'||myPkey||') as foo
               where v.'||myPkey||' = foo.'||myPkey||'    
               group by v.'||myPkey||') as foo
              where v.version_log_id = foo.version_log_id

              union

                select '||fields||', v.action 
                from '||versionLogTable||' as v, 
                  (select v.'||myPkey||', max(v.version_log_id) as version_log_id
                   from '||versionLogTable||' as v,
                     (select v.'||myPkey||' 
                      from '||versionLogTable||' as v
                      where revision > '||myRevision||'
                except
                 (select v.'||myPkey||'
                  from '||versionLogTable||' as v
                  where revision > '||myRevision||'
                  except
                  select v.'||myPkey||'
                  from '||versionLogTable||' as v
                  where revision <= '||myRevision||' 
                 )) as foo
                 where revision <= '||myRevision||' and v.'||myPkey||' = foo.'||myPkey||'    
                group by v.'||myPkey||') as foo
              where v.version_log_id = foo.version_log_id';

  
-- RAISE EXCEPTION '%', rollbackQry;

      execute rollbackQry;
              
--      execute 'select * from versions.pgvscommit('''||mySchema||'.'||myTable||''',''Rollback to Revision '||myRevision||''')';

  RETURN true ;                             

  END;
]]></definition>
</function>

<function name="pgvsupdatecheck"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="versions"/>
	<role name="hdus"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[    
DECLARE
  inRevision ALIAS FOR $1;
  aktRevision TEXT;
  inMajor integer;
  inMinor integer;
  aktMajor integer;
  aktMinor integer;

  
  BEGIN	
      inMajor = to_number(substr(inRevision,1,1),'9');
      inMinor = to_number(substr(inRevision,3,1),'9');
      aktMajor = to_number(substr(versions.pgvsrevision(),1,1),'9');
      aktMinor = to_number(substr(versions.pgvsrevision(),3,1),'9');
      
      if aktMinor>=7 and inMinor<7 THEN
        execute 'select versions._update07()';
        return False;
      ELSE
        return True;
      END IF;
      
  RETURN revision ;                             

  END;
]]></definition>
</function>

<sequence name="version_tables_version_table_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="versions"/>
	<role name="hdus"/>
</sequence>

<sequence name="version_tables_logmsg_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="versions"/>
	<role name="hdus_cp"/>
</sequence>

<table name="version_tables_logmsg">
	<schema name="versions"/>
	<role name="hdus_cp"/>
	<position x="541.5" y="37"/>
	<column name="id" not-null="true" default-value="nextval('version_tables_logmsg_id_seq'::regclass)">
		<type name="bigint"/>
	</column>
	<column name="version_table_id">
		<type name="bigint"/>
	</column>
	<column name="revision">
		<type name="character varying"/>
	</column>
	<column name="logmsg">
		<type name="character varying"/>
	</column>
	<column name="systime" default-value="(date_part('epoch'::text, now()) * (1000)::double precision)">
		<type name="bigint"/>
	</column>
	<column name="project" default-value="&quot;current_user&quot;()">
		<type name="character varying"/>
	</column>
	<constraint name="version_tables_logmsg_pkey" type="pk-constr" table="versions.version_tables_logmsg">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="version_tables">
	<schema name="versions"/>
	<role name="hdus"/>
	<position x="50" y="50"/>
	<column name="version_table_id" not-null="true" default-value="nextval('version_tables_version_table_id_seq'::regclass)">
		<type name="bigint"/>
	</column>
	<column name="version_table_schema">
		<type name="character varying"/>
	</column>
	<column name="version_table_name">
		<type name="character varying"/>
	</column>
	<column name="version_view_schema">
		<type name="character varying"/>
	</column>
	<column name="version_view_name">
		<type name="character varying"/>
	</column>
	<column name="version_view_pkey">
		<type name="character varying"/>
	</column>
	<column name="version_view_geometry_column">
		<type name="character varying"/>
	</column>
	<constraint name="version_table_pkey" type="pk-constr" table="versions.version_tables">
		<columns names="version_table_id" ref-type="src-columns"/>
	</constraint>
</table>

<index name="fki_version_tables_fkey" table="versions.version_tables_logmsg"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="version_table_id"/>
		</idxelement>
</index>

<table name="version_branches">
	<schema name="versions"/>
	<role name="postgres"/>
	<position x="600" y="278"/>
	<column name="id" not-null="true">
		<type name="bigserial"/>
	</column>
	<column name="branch">
		<type name="character varying"/>
	</column>
	<constraint name="version_branchesId_pkey" type="pk-constr" table="versions.version_branches">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<relationship name="version_branches" type="relnn"
	 src-col-pattern="{sc}_{st}" dst-col-pattern="{sc}_{dt}"
	 pk-pattern="{gt}_pk" uq-pattern="{gt}_uq"
	 src-fk-pattern="{st}_fk" dst-fk-pattern="{dt}_fk"
	 pk-col-pattern="id"
	 custom-color="#d9bef0"
	 src-table="versions.version_branches"
	 dst-table="versions.version_tables_logmsg"
	 src-required="false" dst-required="false"
	 table-name="version_branches">
	<label ref-type="name-label">
		<position x="-33.771" y="3.78934"/>
	</label>
</relationship>

<table name="version_tags">
	<schema name="versions"/>
	<role name="postgres"/>
	<position x="225.219" y="249.2"/>
	<column name="tags_id">
		<type name="bigserial"/>
	</column>
	<column name="tag_text">
		<type name="varchar"/>
	</column>
</table>

<relationship name="version_tables_has_many_version_tags" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#bbb825"
	 src-table="versions.version_tables"
	 dst-table="versions.version_tags"
	 src-required="false" dst-required="false"/>

<constraint name="version_tables_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="versions.version_tables" table="versions.version_tables_logmsg">
	<columns names="version_table_id" ref-type="src-columns"/>
	<columns names="version_table_id" ref-type="dst-columns"/>
</constraint>

<relationship name="rel_version_tables_logmsg_version_tables" type="relfk"
	 custom-color="#df64ed"
	 src-table="versions.version_tables_logmsg"
	 dst-table="versions.version_tables"
	 src-required="false" dst-required="false"/>

<permission>
	<object name="versions" type="schema"/>
	<roles names="hdus_cp"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="versions" type="schema"/>
	<privileges create="true" usage="true"/>
</permission>
</dbmodel>
